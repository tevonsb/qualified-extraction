{"$message_type":"diagnostic","message":"failed to resolve: could not find `DataSourceType` in the crate root","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":1120,"byte_end":1134,"line_start":31,"line_end":31,"column_start":24,"column_end":38,"is_primary":true,"text":[{"text":"                crate::DataSourceType::Messages => (","highlight_start":24,"highlight_end":38}],"label":"could not find `DataSourceType` in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `DataSourceType` in the crate root\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:31:24\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m31\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 crate::DataSourceType::Messages => (\n   \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `DataSourceType` in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `DataSourceType` in the crate root","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":1304,"byte_end":1318,"line_start":35,"line_end":35,"column_start":24,"column_end":38,"is_primary":true,"text":[{"text":"                crate::DataSourceType::Chrome => (","highlight_start":24,"highlight_end":38}],"label":"could not find `DataSourceType` in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `DataSourceType` in the crate root\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:35:24\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 crate::DataSourceType::Chrome => (\n   \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `DataSourceType` in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `DataSourceType` in the crate root","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":1673,"byte_end":1687,"line_start":42,"line_end":42,"column_start":24,"column_end":38,"is_primary":true,"text":[{"text":"                crate::DataSourceType::KnowledgeC => (","highlight_start":24,"highlight_end":38}],"label":"could not find `DataSourceType` in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `DataSourceType` in the crate root\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:42:24\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m42\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 crate::DataSourceType::KnowledgeC => (\n   \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `DataSourceType` in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `DataSourceType` in the crate root","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":1888,"byte_end":1902,"line_start":46,"line_end":46,"column_start":24,"column_end":38,"is_primary":true,"text":[{"text":"                crate::DataSourceType::Podcasts => (","highlight_start":24,"highlight_end":38}],"label":"could not find `DataSourceType` in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `DataSourceType` in the crate root\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:46:24\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m46\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 crate::DataSourceType::Podcasts => (\n   \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `DataSourceType` in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `DataSourceType` in the crate root","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":3872,"byte_end":3886,"line_start":100,"line_end":100,"column_start":16,"column_end":30,"is_primary":true,"text":[{"text":"        crate::DataSourceType::Messages => CollectorType::Messages,","highlight_start":16,"highlight_end":30}],"label":"could not find `DataSourceType` in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `DataSourceType` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:100:16\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m100\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         crate::DataSourceType::Messages => CollectorType::Messages,\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `DataSourceType` in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `DataSourceType` in the crate root","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":3940,"byte_end":3954,"line_start":101,"line_end":101,"column_start":16,"column_end":30,"is_primary":true,"text":[{"text":"        crate::DataSourceType::Chrome => CollectorType::Chrome,","highlight_start":16,"highlight_end":30}],"label":"could not find `DataSourceType` in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `DataSourceType` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:101:16\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m101\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         crate::DataSourceType::Chrome => CollectorType::Chrome,\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `DataSourceType` in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `DataSourceType` in the crate root","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":4004,"byte_end":4018,"line_start":102,"line_end":102,"column_start":16,"column_end":30,"is_primary":true,"text":[{"text":"        crate::DataSourceType::KnowledgeC => CollectorType::KnowledgeC,","highlight_start":16,"highlight_end":30}],"label":"could not find `DataSourceType` in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `DataSourceType` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:102:16\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m102\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         crate::DataSourceType::KnowledgeC => CollectorType::KnowledgeC,\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `DataSourceType` in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `DataSourceType` in the crate root","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":4076,"byte_end":4090,"line_start":103,"line_end":103,"column_start":16,"column_end":30,"is_primary":true,"text":[{"text":"        crate::DataSourceType::Podcasts => CollectorType::Podcasts,","highlight_start":16,"highlight_end":30}],"label":"could not find `DataSourceType` in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `DataSourceType` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:103:16\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m103\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         crate::DataSourceType::Podcasts => CollectorType::Podcasts,\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `DataSourceType` in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `ExtractionError` in the crate root","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":4773,"byte_end":4788,"line_start":124,"line_end":124,"column_start":40,"column_end":55,"is_primary":true,"text":[{"text":"        Error::Database(msg) => crate::ExtractionError::DatabaseError(msg.to_string()),","highlight_start":40,"highlight_end":55}],"label":"could not find `ExtractionError` in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `ExtractionError` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:124:40\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Error::Database(msg) => crate::ExtractionError::DatabaseError(msg.to_string()),\n    \u001b[1m\u001b[94m|\u001b[0m                                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `ExtractionError` in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `ExtractionError` in the crate root","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":4855,"byte_end":4870,"line_start":125,"line_end":125,"column_start":34,"column_end":49,"is_primary":true,"text":[{"text":"        Error::Io(err) => crate::ExtractionError::Other(err.to_string()),","highlight_start":34,"highlight_end":49}],"label":"could not find `ExtractionError` in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `ExtractionError` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:125:34\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Error::Io(err) => crate::ExtractionError::Other(err.to_string()),\n    \u001b[1m\u001b[94m|\u001b[0m                                  \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `ExtractionError` in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `ExtractionError` in the crate root","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":4950,"byte_end":4965,"line_start":127,"line_end":127,"column_start":20,"column_end":35,"is_primary":true,"text":[{"text":"            crate::ExtractionError::SourceNotFound(\"Source database not found\".to_string())","highlight_start":20,"highlight_end":35}],"label":"could not find `ExtractionError` in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `ExtractionError` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:127:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m127\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             crate::ExtractionError::SourceNotFound(\"Source database not found\".to_string())\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `ExtractionError` in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `ExtractionError` in the crate root","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":5074,"byte_end":5089,"line_start":129,"line_end":129,"column_start":42,"column_end":57,"is_primary":true,"text":[{"text":"        Error::CopyFailed(msg) => crate::ExtractionError::ExtractionFailed(msg),","highlight_start":42,"highlight_end":57}],"label":"could not find `ExtractionError` in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `ExtractionError` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:129:42\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m129\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Error::CopyFailed(msg) => crate::ExtractionError::ExtractionFailed(msg),\n    \u001b[1m\u001b[94m|\u001b[0m                                          \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `ExtractionError` in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `ExtractionError` in the crate root","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":5179,"byte_end":5194,"line_start":131,"line_end":131,"column_start":20,"column_end":35,"is_primary":true,"text":[{"text":"            crate::ExtractionError::PermissionDenied(path.display().to_string())","highlight_start":20,"highlight_end":35}],"label":"could not find `ExtractionError` in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `ExtractionError` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:131:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m131\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             crate::ExtractionError::PermissionDenied(path.display().to_string())\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `ExtractionError` in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `ExtractionError` in the crate root","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":5313,"byte_end":5328,"line_start":134,"line_end":134,"column_start":20,"column_end":35,"is_primary":true,"text":[{"text":"            crate::ExtractionError::DatabaseError(format!(\"Database not found: {}\", path.display()))","highlight_start":20,"highlight_end":35}],"label":"could not find `ExtractionError` in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `ExtractionError` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:134:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m134\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             crate::ExtractionError::DatabaseError(format!(\"Database not found: {}\", path.display()))\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `ExtractionError` in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `ExtractionError` in the crate root","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":5452,"byte_end":5467,"line_start":136,"line_end":136,"column_start":48,"column_end":63,"is_primary":true,"text":[{"text":"        Error::InvalidTimestamp(msg) => crate::ExtractionError::Other(msg),","highlight_start":48,"highlight_end":63}],"label":"could not find `ExtractionError` in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `ExtractionError` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:136:48\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Error::InvalidTimestamp(msg) => crate::ExtractionError::Other(msg),\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `ExtractionError` in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `ExtractionError` in the crate root","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":5528,"byte_end":5543,"line_start":137,"line_end":137,"column_start":48,"column_end":63,"is_primary":true,"text":[{"text":"        Error::ExtractionFailed(msg) => crate::ExtractionError::ExtractionFailed(msg),","highlight_start":48,"highlight_end":63}],"label":"could not find `ExtractionError` in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `ExtractionError` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:137:48\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m137\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Error::ExtractionFailed(msg) => crate::ExtractionError::ExtractionFailed(msg),\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `ExtractionError` in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `ExtractionError` in the crate root","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":5619,"byte_end":5634,"line_start":138,"line_end":138,"column_start":52,"column_end":67,"is_primary":true,"text":[{"text":"        Error::UnsupportedCollector(msg) => crate::ExtractionError::Other(msg),","highlight_start":52,"highlight_end":67}],"label":"could not find `ExtractionError` in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `ExtractionError` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:138:52\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m138\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Error::UnsupportedCollector(msg) => crate::ExtractionError::Other(msg),\n    \u001b[1m\u001b[94m|\u001b[0m                                                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `ExtractionError` in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `ExtractionError` in the crate root","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":6045,"byte_end":6060,"line_start":149,"line_end":149,"column_start":27,"column_end":42,"is_primary":true,"text":[{"text":"        return Err(crate::ExtractionError::InvalidPath(format!(","highlight_start":27,"highlight_end":42}],"label":"could not find `ExtractionError` in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `ExtractionError` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:149:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m149\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         return Err(crate::ExtractionError::InvalidPath(format!(\n    \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `ExtractionError` in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `ExtractionError` in the crate root","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":9215,"byte_end":9230,"line_start":240,"line_end":240,"column_start":27,"column_end":42,"is_primary":true,"text":[{"text":"        return Err(crate::ExtractionError::InvalidPath(format!(","highlight_start":27,"highlight_end":42}],"label":"could not find `ExtractionError` in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `ExtractionError` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:240:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m240\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         return Err(crate::ExtractionError::InvalidPath(format!(\n    \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `ExtractionError` in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `ExtractionError` in the crate root","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":11598,"byte_end":11613,"line_start":309,"line_end":309,"column_start":27,"column_end":42,"is_primary":true,"text":[{"text":"        return Err(crate::ExtractionError::DatabaseError(format!(","highlight_start":27,"highlight_end":42}],"label":"could not find `ExtractionError` in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `ExtractionError` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:309:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m309\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         return Err(crate::ExtractionError::DatabaseError(format!(\n    \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `ExtractionError` in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `ExtractionError` in the crate root","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":11798,"byte_end":11813,"line_start":316,"line_end":316,"column_start":29,"column_end":44,"is_primary":true,"text":[{"text":"        .map_err(|e| crate::ExtractionError::DatabaseError(e.to_string()))?;","highlight_start":29,"highlight_end":44}],"label":"could not find `ExtractionError` in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `ExtractionError` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:316:29\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m316\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .map_err(|e| crate::ExtractionError::DatabaseError(e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `ExtractionError` in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `DataSourceType` in the crate root","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":14452,"byte_end":14466,"line_start":401,"line_end":401,"column_start":16,"column_end":30,"is_primary":true,"text":[{"text":"        crate::DataSourceType::Messages => \"Messages\",","highlight_start":16,"highlight_end":30}],"label":"could not find `DataSourceType` in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `DataSourceType` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:401:16\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m401\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         crate::DataSourceType::Messages => \"Messages\",\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `DataSourceType` in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `DataSourceType` in the crate root","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":14507,"byte_end":14521,"line_start":402,"line_end":402,"column_start":16,"column_end":30,"is_primary":true,"text":[{"text":"        crate::DataSourceType::Chrome => \"Chrome Browser\",","highlight_start":16,"highlight_end":30}],"label":"could not find `DataSourceType` in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `DataSourceType` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:402:16\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m402\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         crate::DataSourceType::Chrome => \"Chrome Browser\",\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `DataSourceType` in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `DataSourceType` in the crate root","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":14566,"byte_end":14580,"line_start":403,"line_end":403,"column_start":16,"column_end":30,"is_primary":true,"text":[{"text":"        crate::DataSourceType::KnowledgeC => \"System Activity\",","highlight_start":16,"highlight_end":30}],"label":"could not find `DataSourceType` in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `DataSourceType` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:403:16\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m403\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         crate::DataSourceType::KnowledgeC => \"System Activity\",\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `DataSourceType` in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `DataSourceType` in the crate root","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":14630,"byte_end":14644,"line_start":404,"line_end":404,"column_start":16,"column_end":30,"is_primary":true,"text":[{"text":"        crate::DataSourceType::Podcasts => \"Podcasts\",","highlight_start":16,"highlight_end":30}],"label":"could not find `DataSourceType` in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `DataSourceType` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:404:16\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m404\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         crate::DataSourceType::Podcasts => \"Podcasts\",\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `DataSourceType` in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `DataSourceInfo` in the crate root","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":797,"byte_end":811,"line_start":19,"line_end":19,"column_start":42,"column_end":56,"is_primary":true,"text":[{"text":"pub fn scan_data_sources() -> Vec<crate::DataSourceInfo> {","highlight_start":42,"highlight_end":56}],"label":"not found in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `DataSourceInfo` in the crate root\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:19:42\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn scan_data_sources() -> Vec<crate::DataSourceInfo> {\n   \u001b[1m\u001b[94m|\u001b[0m                                          \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `DataSourceInfo` in the crate root","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":2210,"byte_end":2224,"line_start":54,"line_end":54,"column_start":35,"column_end":49,"is_primary":true,"text":[{"text":"            let mut info = crate::DataSourceInfo {","highlight_start":35,"highlight_end":49}],"label":"not found in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0422]\u001b[0m\u001b[1m: cannot find struct, variant or union type `DataSourceInfo` in the crate root\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:54:35\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let mut info = crate::DataSourceInfo {\n   \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `DataSourceType` in the crate root","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":3798,"byte_end":3812,"line_start":98,"line_end":98,"column_start":42,"column_end":56,"is_primary":true,"text":[{"text":"fn to_collector_type(source_type: crate::DataSourceType) -> CollectorType {","highlight_start":42,"highlight_end":56}],"label":"not found in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `DataSourceType` in the crate root\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:98:42\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m fn to_collector_type(source_type: crate::DataSourceType) -> CollectorType {\n   \u001b[1m\u001b[94m|\u001b[0m                                          \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `ExtractionConfig` in the crate root","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/types.rs","byte_start":168,"byte_end":195,"line_start":8,"line_end":8,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"pub struct ExtractionConfig {","highlight_start":1,"highlight_end":28}],"label":"similarly named struct `CoreExtractionConfig` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/uniffi_api.rs","byte_start":4241,"byte_end":4257,"line_start":108,"line_end":108,"column_start":35,"column_end":51,"is_primary":true,"text":[{"text":"fn to_core_config(config: &crate::ExtractionConfig) -> CoreExtractionConfig {","highlight_start":35,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a struct with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/uniffi_api.rs","byte_start":4241,"byte_end":4257,"line_start":108,"line_end":108,"column_start":35,"column_end":51,"is_primary":true,"text":[{"text":"fn to_core_config(config: &crate::ExtractionConfig) -> CoreExtractionConfig {","highlight_start":35,"highlight_end":51}],"label":null,"suggested_replacement":"CoreExtractionConfig","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/uniffi_api.rs","byte_start":291,"byte_end":291,"line_start":7,"line_end":7,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use crate::collectors;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::types::ExtractionConfig;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `ExtractionConfig`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"src/uniffi_api.rs","byte_start":4234,"byte_end":4241,"line_start":108,"line_end":108,"column_start":28,"column_end":35,"is_primary":true,"text":[{"text":"fn to_core_config(config: &crate::ExtractionConfig) -> CoreExtractionConfig {","highlight_start":28,"highlight_end":35}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `ExtractionConfig` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:108:35\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m108\u001b[0m \u001b[1m\u001b[94m|\u001b[0m fn to_core_config(config: &crate::ExtractionConfig) -> CoreExtractionConfig {\n    \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/types.rs:8:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ExtractionConfig {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m---------------------------\u001b[0m \u001b[1m\u001b[94msimilarly named struct `CoreExtractionConfig` defined here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: a struct with a similar name exists\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m108\u001b[0m \u001b[1m\u001b[94m| \u001b[0mfn to_core_config(config: &crate::\u001b[92mCore\u001b[0mExtractionConfig) -> CoreExtractionConfig {\n    \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[92m++++\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[92m+ use crate::types::ExtractionConfig;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `ExtractionConfig`, refer to it directly\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m108\u001b[0m \u001b[91m- \u001b[0mfn to_core_config(config: &\u001b[91mcrate::\u001b[0mExtractionConfig) -> CoreExtractionConfig {\n\u001b[1m\u001b[94m108\u001b[0m \u001b[92m+ \u001b[0mfn to_core_config(config: &ExtractionConfig) -> CoreExtractionConfig {\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `ExtractionError` in the crate root","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":4700,"byte_end":4715,"line_start":122,"line_end":122,"column_start":46,"column_end":61,"is_primary":true,"text":[{"text":"fn to_extraction_error(err: Error) -> crate::ExtractionError {","highlight_start":46,"highlight_end":61}],"label":"not found in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `ExtractionError` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:122:46\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m122\u001b[0m \u001b[1m\u001b[94m|\u001b[0m fn to_extraction_error(err: Error) -> crate::ExtractionError {\n    \u001b[1m\u001b[94m|\u001b[0m                                              \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `ExtractionConfig` in the crate root","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/types.rs","byte_start":168,"byte_end":195,"line_start":8,"line_end":8,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"pub struct ExtractionConfig {","highlight_start":1,"highlight_end":28}],"label":"similarly named struct `CoreExtractionConfig` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/uniffi_api.rs","byte_start":5738,"byte_end":5754,"line_start":143,"line_end":143,"column_start":40,"column_end":56,"is_primary":true,"text":[{"text":"pub fn extract_all_data(config: crate::ExtractionConfig) -> std::result::Result<crate::ExtractionReport, crate::ExtractionError> {","highlight_start":40,"highlight_end":56}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a struct with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/uniffi_api.rs","byte_start":5738,"byte_end":5754,"line_start":143,"line_end":143,"column_start":40,"column_end":56,"is_primary":true,"text":[{"text":"pub fn extract_all_data(config: crate::ExtractionConfig) -> std::result::Result<crate::ExtractionReport, crate::ExtractionError> {","highlight_start":40,"highlight_end":56}],"label":null,"suggested_replacement":"CoreExtractionConfig","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/uniffi_api.rs","byte_start":291,"byte_end":291,"line_start":7,"line_end":7,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use crate::collectors;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::types::ExtractionConfig;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `ExtractionConfig`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"src/uniffi_api.rs","byte_start":5731,"byte_end":5738,"line_start":143,"line_end":143,"column_start":33,"column_end":40,"is_primary":true,"text":[{"text":"pub fn extract_all_data(config: crate::ExtractionConfig) -> std::result::Result<crate::ExtractionReport, crate::ExtractionError> {","highlight_start":33,"highlight_end":40}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `ExtractionConfig` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:143:40\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m143\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn extract_all_data(config: crate::ExtractionConfig) -> std::result::Result<crate::ExtractionReport, crate::ExtractionError> {\n    \u001b[1m\u001b[94m|\u001b[0m                                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/types.rs:8:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ExtractionConfig {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m---------------------------\u001b[0m \u001b[1m\u001b[94msimilarly named struct `CoreExtractionConfig` defined here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: a struct with a similar name exists\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m143\u001b[0m \u001b[1m\u001b[94m| \u001b[0mpub fn extract_all_data(config: crate::\u001b[92mCore\u001b[0mExtractionConfig) -> std::result::Result<crate::ExtractionReport, crate::ExtractionError> {\n    \u001b[1m\u001b[94m|\u001b[0m                                        \u001b[92m++++\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[92m+ use crate::types::ExtractionConfig;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `ExtractionConfig`, refer to it directly\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m143\u001b[0m \u001b[91m- \u001b[0mpub fn extract_all_data(config: \u001b[91mcrate::\u001b[0mExtractionConfig) -> std::result::Result<crate::ExtractionReport, crate::ExtractionError> {\n\u001b[1m\u001b[94m143\u001b[0m \u001b[92m+ \u001b[0mpub fn extract_all_data(config: ExtractionConfig) -> std::result::Result<crate::ExtractionReport, crate::ExtractionError> {\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `ExtractionReport` in the crate root","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/types.rs","byte_start":1618,"byte_end":1645,"line_start":63,"line_end":63,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"pub struct ExtractionResult {","highlight_start":1,"highlight_end":28}],"label":"similarly named struct `ExtractionResult` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/uniffi_api.rs","byte_start":5786,"byte_end":5802,"line_start":143,"line_end":143,"column_start":88,"column_end":104,"is_primary":true,"text":[{"text":"pub fn extract_all_data(config: crate::ExtractionConfig) -> std::result::Result<crate::ExtractionReport, crate::ExtractionError> {","highlight_start":88,"highlight_end":104}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a struct with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/uniffi_api.rs","byte_start":5786,"byte_end":5802,"line_start":143,"line_end":143,"column_start":88,"column_end":104,"is_primary":true,"text":[{"text":"pub fn extract_all_data(config: crate::ExtractionConfig) -> std::result::Result<crate::ExtractionReport, crate::ExtractionError> {","highlight_start":88,"highlight_end":104}],"label":null,"suggested_replacement":"ExtractionResult","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `ExtractionReport` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:143:88\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m143\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn extract_all_data(config: crate::ExtractionConfig) -> std::result::Result<crate::ExtractionReport, crate::ExtractionError> {\n    \u001b[1m\u001b[94m|\u001b[0m                                                                                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: a struct with a similar name exists: `ExtractionResult`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/types.rs:63:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m63\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ExtractionResult {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m---------------------------\u001b[0m \u001b[1m\u001b[94msimilarly named struct `ExtractionResult` defined here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `ExtractionError` in the crate root","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":5811,"byte_end":5826,"line_start":143,"line_end":143,"column_start":113,"column_end":128,"is_primary":true,"text":[{"text":"pub fn extract_all_data(config: crate::ExtractionConfig) -> std::result::Result<crate::ExtractionReport, crate::ExtractionError> {","highlight_start":113,"highlight_end":128}],"label":"not found in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `ExtractionError` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:143:113\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m143\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn extract_all_data(config: crate::ExtractionConfig) -> std::result::Result<crate::ExtractionReport, crate::ExtractionError> {\n    \u001b[1m\u001b[94m|\u001b[0m                                                                                                                 \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `SourceResult` in the crate root","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":7038,"byte_end":7050,"line_start":177,"line_end":177,"column_start":28,"column_end":40,"is_primary":true,"text":[{"text":"                    crate::SourceResult {","highlight_start":28,"highlight_end":40}],"label":"not found in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0422]\u001b[0m\u001b[1m: cannot find struct, variant or union type `SourceResult` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:177:28\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m177\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     crate::SourceResult {\n    \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `SourceResult` in the crate root","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":7544,"byte_end":7556,"line_start":188,"line_end":188,"column_start":28,"column_end":40,"is_primary":true,"text":[{"text":"                    crate::SourceResult {","highlight_start":28,"highlight_end":40}],"label":"not found in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0422]\u001b[0m\u001b[1m: cannot find struct, variant or union type `SourceResult` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:188:28\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m188\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     crate::SourceResult {\n    \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `SourceResult` in the crate root","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":7993,"byte_end":8005,"line_start":200,"line_end":200,"column_start":24,"column_end":36,"is_primary":true,"text":[{"text":"                crate::SourceResult {","highlight_start":24,"highlight_end":36}],"label":"not found in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0422]\u001b[0m\u001b[1m: cannot find struct, variant or union type `SourceResult` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:200:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m200\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 crate::SourceResult {\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `ExtractionReport` in the crate root","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"src/types.rs","byte_start":1618,"byte_end":1645,"line_start":63,"line_end":63,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"pub struct ExtractionResult {","highlight_start":1,"highlight_end":28}],"label":"similarly named struct `ExtractionResult` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/uniffi_api.rs","byte_start":8407,"byte_end":8423,"line_start":216,"line_end":216,"column_start":15,"column_end":31,"is_primary":true,"text":[{"text":"    Ok(crate::ExtractionReport {","highlight_start":15,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a struct with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/uniffi_api.rs","byte_start":8407,"byte_end":8423,"line_start":216,"line_end":216,"column_start":15,"column_end":31,"is_primary":true,"text":[{"text":"    Ok(crate::ExtractionReport {","highlight_start":15,"highlight_end":31}],"label":null,"suggested_replacement":"ExtractionResult","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0422]\u001b[0m\u001b[1m: cannot find struct, variant or union type `ExtractionReport` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:216:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m216\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(crate::ExtractionReport {\n    \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: a struct with a similar name exists: `ExtractionResult`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/types.rs:63:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m63\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ExtractionResult {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m---------------------------\u001b[0m \u001b[1m\u001b[94msimilarly named struct `ExtractionResult` defined here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `ExtractionConfig` in the crate root","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/types.rs","byte_start":168,"byte_end":195,"line_start":8,"line_end":8,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"pub struct ExtractionConfig {","highlight_start":1,"highlight_end":28}],"label":"similarly named struct `CoreExtractionConfig` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/uniffi_api.rs","byte_start":8866,"byte_end":8882,"line_start":232,"line_end":232,"column_start":20,"column_end":36,"is_primary":true,"text":[{"text":"    config: crate::ExtractionConfig,","highlight_start":20,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a struct with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/uniffi_api.rs","byte_start":8866,"byte_end":8882,"line_start":232,"line_end":232,"column_start":20,"column_end":36,"is_primary":true,"text":[{"text":"    config: crate::ExtractionConfig,","highlight_start":20,"highlight_end":36}],"label":null,"suggested_replacement":"CoreExtractionConfig","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/uniffi_api.rs","byte_start":291,"byte_end":291,"line_start":7,"line_end":7,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use crate::collectors;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::types::ExtractionConfig;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `ExtractionConfig`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"src/uniffi_api.rs","byte_start":8859,"byte_end":8866,"line_start":232,"line_end":232,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"    config: crate::ExtractionConfig,","highlight_start":13,"highlight_end":20}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `ExtractionConfig` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:232:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m232\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     config: crate::ExtractionConfig,\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/types.rs:8:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ExtractionConfig {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m---------------------------\u001b[0m \u001b[1m\u001b[94msimilarly named struct `CoreExtractionConfig` defined here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: a struct with a similar name exists\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m232\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    config: crate::\u001b[92mCore\u001b[0mExtractionConfig,\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[92m++++\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[92m+ use crate::types::ExtractionConfig;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `ExtractionConfig`, refer to it directly\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m232\u001b[0m \u001b[91m- \u001b[0m    config: \u001b[91mcrate::\u001b[0mExtractionConfig,\n\u001b[1m\u001b[94m232\u001b[0m \u001b[92m+ \u001b[0m    config: ExtractionConfig,\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `DataSourceType` in the crate root","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":8908,"byte_end":8922,"line_start":233,"line_end":233,"column_start":25,"column_end":39,"is_primary":true,"text":[{"text":"    source_type: crate::DataSourceType,","highlight_start":25,"highlight_end":39}],"label":"not found in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `DataSourceType` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:233:25\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m233\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     source_type: crate::DataSourceType,\n    \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `ExtractionReport` in the crate root","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/types.rs","byte_start":1618,"byte_end":1645,"line_start":63,"line_end":63,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"pub struct ExtractionResult {","highlight_start":1,"highlight_end":28}],"label":"similarly named struct `ExtractionResult` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/uniffi_api.rs","byte_start":8956,"byte_end":8972,"line_start":234,"line_end":234,"column_start":33,"column_end":49,"is_primary":true,"text":[{"text":") -> std::result::Result<crate::ExtractionReport, crate::ExtractionError> {","highlight_start":33,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a struct with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/uniffi_api.rs","byte_start":8956,"byte_end":8972,"line_start":234,"line_end":234,"column_start":33,"column_end":49,"is_primary":true,"text":[{"text":") -> std::result::Result<crate::ExtractionReport, crate::ExtractionError> {","highlight_start":33,"highlight_end":49}],"label":null,"suggested_replacement":"ExtractionResult","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `ExtractionReport` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:234:33\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m234\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> std::result::Result<crate::ExtractionReport, crate::ExtractionError> {\n    \u001b[1m\u001b[94m|\u001b[0m                                 \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: a struct with a similar name exists: `ExtractionResult`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/types.rs:63:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m63\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ExtractionResult {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m---------------------------\u001b[0m \u001b[1m\u001b[94msimilarly named struct `ExtractionResult` defined here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `ExtractionError` in the crate root","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":8981,"byte_end":8996,"line_start":234,"line_end":234,"column_start":58,"column_end":73,"is_primary":true,"text":[{"text":") -> std::result::Result<crate::ExtractionReport, crate::ExtractionError> {","highlight_start":58,"highlight_end":73}],"label":"not found in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `ExtractionError` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:234:58\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m234\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> std::result::Result<crate::ExtractionReport, crate::ExtractionError> {\n    \u001b[1m\u001b[94m|\u001b[0m                                                          \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `SourceResult` in the crate root","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":9782,"byte_end":9794,"line_start":256,"line_end":256,"column_start":45,"column_end":57,"is_primary":true,"text":[{"text":"            Ok(extraction_result) => crate::SourceResult {","highlight_start":45,"highlight_end":57}],"label":"not found in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0422]\u001b[0m\u001b[1m: cannot find struct, variant or union type `SourceResult` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:256:45\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m256\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             Ok(extraction_result) => crate::SourceResult {\n    \u001b[1m\u001b[94m|\u001b[0m                                             \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `SourceResult` in the crate root","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":10144,"byte_end":10156,"line_start":264,"line_end":264,"column_start":30,"column_end":42,"is_primary":true,"text":[{"text":"            Err(e) => crate::SourceResult {","highlight_start":30,"highlight_end":42}],"label":"not found in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0422]\u001b[0m\u001b[1m: cannot find struct, variant or union type `SourceResult` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:264:30\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m264\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             Err(e) => crate::SourceResult {\n    \u001b[1m\u001b[94m|\u001b[0m                              \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `SourceResult` in the crate root","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":10453,"byte_end":10465,"line_start":273,"line_end":273,"column_start":26,"column_end":38,"is_primary":true,"text":[{"text":"        Err(e) => crate::SourceResult {","highlight_start":26,"highlight_end":38}],"label":"not found in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0422]\u001b[0m\u001b[1m: cannot find struct, variant or union type `SourceResult` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:273:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m273\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Err(e) => crate::SourceResult {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `ExtractionReport` in the crate root","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"src/types.rs","byte_start":1618,"byte_end":1645,"line_start":63,"line_end":63,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"pub struct ExtractionResult {","highlight_start":1,"highlight_end":28}],"label":"similarly named struct `ExtractionResult` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/uniffi_api.rs","byte_start":10887,"byte_end":10903,"line_start":288,"line_end":288,"column_start":15,"column_end":31,"is_primary":true,"text":[{"text":"    Ok(crate::ExtractionReport {","highlight_start":15,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a struct with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/uniffi_api.rs","byte_start":10887,"byte_end":10903,"line_start":288,"line_end":288,"column_start":15,"column_end":31,"is_primary":true,"text":[{"text":"    Ok(crate::ExtractionReport {","highlight_start":15,"highlight_end":31}],"label":null,"suggested_replacement":"ExtractionResult","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0422]\u001b[0m\u001b[1m: cannot find struct, variant or union type `ExtractionReport` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:288:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m288\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(crate::ExtractionReport {\n    \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: a struct with a similar name exists: `ExtractionResult`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/types.rs:63:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m63\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ExtractionResult {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m---------------------------\u001b[0m \u001b[1m\u001b[94msimilarly named struct `ExtractionResult` defined here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `DatabaseStats` in the crate root","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":11359,"byte_end":11372,"line_start":303,"line_end":303,"column_start":77,"column_end":90,"is_primary":true,"text":[{"text":"pub fn get_database_stats(output_dir: String) -> std::result::Result<crate::DatabaseStats, crate::ExtractionError> {","highlight_start":77,"highlight_end":90}],"label":"not found in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `DatabaseStats` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:303:77\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m303\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn get_database_stats(output_dir: String) -> std::result::Result<crate::DatabaseStats, crate::ExtractionError> {\n    \u001b[1m\u001b[94m|\u001b[0m                                                                             \u001b[1m\u001b[91m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `ExtractionError` in the crate root","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":11381,"byte_end":11396,"line_start":303,"line_end":303,"column_start":99,"column_end":114,"is_primary":true,"text":[{"text":"pub fn get_database_stats(output_dir: String) -> std::result::Result<crate::DatabaseStats, crate::ExtractionError> {","highlight_start":99,"highlight_end":114}],"label":"not found in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `ExtractionError` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:303:99\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m303\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn get_database_stats(output_dir: String) -> std::result::Result<crate::DatabaseStats, crate::ExtractionError> {\n    \u001b[1m\u001b[94m|\u001b[0m                                                                                                   \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `DatabaseStats` in the crate root","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":13952,"byte_end":13965,"line_start":387,"line_end":387,"column_start":15,"column_end":28,"is_primary":true,"text":[{"text":"    Ok(crate::DatabaseStats {","highlight_start":15,"highlight_end":28}],"label":"not found in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0422]\u001b[0m\u001b[1m: cannot find struct, variant or union type `DatabaseStats` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:387:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m387\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(crate::DatabaseStats {\n    \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[91m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `DataSourceType` in the crate root","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":14385,"byte_end":14399,"line_start":399,"line_end":399,"column_start":41,"column_end":55,"is_primary":true,"text":[{"text":"fn source_type_name(source_type: crate::DataSourceType) -> String {","highlight_start":41,"highlight_end":55}],"label":"not found in the crate root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `DataSourceType` in the crate root\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:399:41\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m399\u001b[0m \u001b[1m\u001b[94m|\u001b[0m fn source_type_name(source_type: crate::DataSourceType) -> String {\n    \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in the crate root\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `DataSourceType` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":844,"byte_end":860,"line_start":46,"line_end":46,"column_start":6,"column_end":22,"is_primary":true,"text":[{"text":"enum r#DataSourceType {","highlight_start":6,"highlight_end":22}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `DataSourceType` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:46:6\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m46\u001b[0m \u001b[1m\u001b[94m|\u001b[0m enum r#DataSourceType {\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `ExtractionError` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":1084,"byte_end":1101,"line_start":65,"line_end":65,"column_start":6,"column_end":23,"is_primary":true,"text":[{"text":"enum r#ExtractionError {","highlight_start":6,"highlight_end":23}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `ExtractionError` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:65:6\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m65\u001b[0m \u001b[1m\u001b[94m|\u001b[0m enum r#ExtractionError {\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `DataSourceInfo` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":1420,"byte_end":1436,"line_start":87,"line_end":87,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"struct r#DataSourceInfo {","highlight_start":8,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `DataSourceInfo` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:87:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m87\u001b[0m \u001b[1m\u001b[94m|\u001b[0m struct r#DataSourceInfo {\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `DataSourceType` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":1458,"byte_end":1474,"line_start":88,"line_end":88,"column_start":20,"column_end":36,"is_primary":true,"text":[{"text":"    r#source_type: r#DataSourceType,","highlight_start":20,"highlight_end":36}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `DataSourceType` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:88:20\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m88\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     r#source_type: r#DataSourceType,\n   \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `DatabaseStats` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":1750,"byte_end":1765,"line_start":99,"line_end":99,"column_start":8,"column_end":23,"is_primary":true,"text":[{"text":"struct r#DatabaseStats {","highlight_start":8,"highlight_end":23}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `DatabaseStats` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:99:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m struct r#DatabaseStats {\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `ExtractionConfig` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/types.rs","byte_start":168,"byte_end":195,"line_start":8,"line_end":8,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"pub struct ExtractionConfig {","highlight_start":1,"highlight_end":28}],"label":"similarly named struct `CoreExtractionConfig` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":2089,"byte_end":2107,"line_start":112,"line_end":112,"column_start":8,"column_end":26,"is_primary":true,"text":[{"text":"struct r#ExtractionConfig {","highlight_start":8,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a struct with a similar name exists","code":null,"level":"help","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":2089,"byte_end":2107,"line_start":112,"line_end":112,"column_start":8,"column_end":26,"is_primary":true,"text":[{"text":"struct r#ExtractionConfig {","highlight_start":8,"highlight_end":26}],"label":null,"suggested_replacement":"CoreExtractionConfig","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":736,"byte_end":736,"line_start":27,"line_end":27,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub use error::{Error, Result};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::types::ExtractionConfig;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `ExtractionConfig` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:112:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m112\u001b[0m \u001b[1m\u001b[94m|\u001b[0m struct r#ExtractionConfig {\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/types.rs:8:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ExtractionConfig {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m---------------------------\u001b[0m \u001b[1m\u001b[94msimilarly named struct `CoreExtractionConfig` defined here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: a struct with a similar name exists\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m112\u001b[0m \u001b[91m- \u001b[0mstruct \u001b[91mr#ExtractionConfig\u001b[0m {\n\u001b[1m\u001b[94m112\u001b[0m \u001b[92m+ \u001b[0mstruct \u001b[92mCoreExtractionConfig\u001b[0m {\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:27:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m27\u001b[0m \u001b[92m+ use crate::types::ExtractionConfig;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `DataSourceType` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":2188,"byte_end":2204,"line_start":114,"line_end":114,"column_start":38,"column_end":54,"is_primary":true,"text":[{"text":"    r#enabled_sources: std::vec::Vec<r#DataSourceType>,","highlight_start":38,"highlight_end":54}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `DataSourceType` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:114:38\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m114\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     r#enabled_sources: std::vec::Vec<r#DataSourceType>,\n    \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `ExtractionReport` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/types.rs","byte_start":1618,"byte_end":1645,"line_start":63,"line_end":63,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"pub struct ExtractionResult {","highlight_start":1,"highlight_end":28}],"label":"similarly named struct `ExtractionResult` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":2272,"byte_end":2290,"line_start":121,"line_end":121,"column_start":8,"column_end":26,"is_primary":true,"text":[{"text":"struct r#ExtractionReport {","highlight_start":8,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a struct with a similar name exists","code":null,"level":"help","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":2272,"byte_end":2290,"line_start":121,"line_end":121,"column_start":8,"column_end":26,"is_primary":true,"text":[{"text":"struct r#ExtractionReport {","highlight_start":8,"highlight_end":26}],"label":null,"suggested_replacement":"ExtractionResult","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `ExtractionReport` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:121:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m121\u001b[0m \u001b[1m\u001b[94m|\u001b[0m struct r#ExtractionReport {\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: a struct with a similar name exists: `ExtractionResult`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/types.rs:63:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m63\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ExtractionResult {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m---------------------------\u001b[0m \u001b[1m\u001b[94msimilarly named struct `ExtractionResult` defined here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `SourceResult` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":2322,"byte_end":2336,"line_start":122,"line_end":122,"column_start":30,"column_end":44,"is_primary":true,"text":[{"text":"    r#results: std::vec::Vec<r#SourceResult>,","highlight_start":30,"highlight_end":44}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `SourceResult` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:122:30\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m122\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     r#results: std::vec::Vec<r#SourceResult>,\n    \u001b[1m\u001b[94m|\u001b[0m                              \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `SourceResult` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":2566,"byte_end":2580,"line_start":133,"line_end":133,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"struct r#SourceResult {","highlight_start":8,"highlight_end":22}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `SourceResult` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:133:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m133\u001b[0m \u001b[1m\u001b[94m|\u001b[0m struct r#SourceResult {\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `DataSourceType` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":2602,"byte_end":2618,"line_start":134,"line_end":134,"column_start":20,"column_end":36,"is_primary":true,"text":[{"text":"    r#source_type: r#DataSourceType,","highlight_start":20,"highlight_end":36}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `DataSourceType` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:134:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m134\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     r#source_type: r#DataSourceType,\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `ExtractionConfig` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/types.rs","byte_start":168,"byte_end":195,"line_start":8,"line_end":8,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"pub struct ExtractionConfig {","highlight_start":1,"highlight_end":28}],"label":"similarly named struct `CoreExtractionConfig` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":2946,"byte_end":2964,"line_start":147,"line_end":147,"column_start":15,"column_end":33,"is_primary":true,"text":[{"text":"    r#config: r#ExtractionConfig,","highlight_start":15,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a struct with a similar name exists","code":null,"level":"help","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":2946,"byte_end":2964,"line_start":147,"line_end":147,"column_start":15,"column_end":33,"is_primary":true,"text":[{"text":"    r#config: r#ExtractionConfig,","highlight_start":15,"highlight_end":33}],"label":null,"suggested_replacement":"CoreExtractionConfig","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":736,"byte_end":736,"line_start":27,"line_end":27,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub use error::{Error, Result};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::types::ExtractionConfig;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `ExtractionConfig` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:147:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m147\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     r#config: r#ExtractionConfig,\n    \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/types.rs:8:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ExtractionConfig {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m---------------------------\u001b[0m \u001b[1m\u001b[94msimilarly named struct `CoreExtractionConfig` defined here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: a struct with a similar name exists\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m147\u001b[0m \u001b[91m- \u001b[0m    r#config: \u001b[91mr#ExtractionConfig\u001b[0m,\n\u001b[1m\u001b[94m147\u001b[0m \u001b[92m+ \u001b[0m    r#config: \u001b[92mCoreExtractionConfig\u001b[0m,\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:27:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m27\u001b[0m \u001b[92m+ use crate::types::ExtractionConfig;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `ExtractionReport` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/types.rs","byte_start":1618,"byte_end":1645,"line_start":63,"line_end":63,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"pub struct ExtractionResult {","highlight_start":1,"highlight_end":28}],"label":"similarly named struct `ExtractionResult` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":2995,"byte_end":3013,"line_start":148,"line_end":148,"column_start":30,"column_end":48,"is_primary":true,"text":[{"text":") -> ::std::result::Result::<r#ExtractionReport, r#ExtractionError>","highlight_start":30,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a struct with a similar name exists","code":null,"level":"help","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":2995,"byte_end":3013,"line_start":148,"line_end":148,"column_start":30,"column_end":48,"is_primary":true,"text":[{"text":") -> ::std::result::Result::<r#ExtractionReport, r#ExtractionError>","highlight_start":30,"highlight_end":48}],"label":null,"suggested_replacement":"ExtractionResult","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `ExtractionReport` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:148:30\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m148\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ::std::result::Result::<r#ExtractionReport, r#ExtractionError>\n    \u001b[1m\u001b[94m|\u001b[0m                              \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: a struct with a similar name exists: `ExtractionResult`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/types.rs:63:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m63\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ExtractionResult {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m---------------------------\u001b[0m \u001b[1m\u001b[94msimilarly named struct `ExtractionResult` defined here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `ExtractionError` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":3015,"byte_end":3032,"line_start":148,"line_end":148,"column_start":50,"column_end":67,"is_primary":true,"text":[{"text":") -> ::std::result::Result::<r#ExtractionReport, r#ExtractionError>","highlight_start":50,"highlight_end":67}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `ExtractionError` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:148:50\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m148\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ::std::result::Result::<r#ExtractionReport, r#ExtractionError>\n    \u001b[1m\u001b[94m|\u001b[0m                                                  \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `ExtractionConfig` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/types.rs","byte_start":168,"byte_end":195,"line_start":8,"line_end":8,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"pub struct ExtractionConfig {","highlight_start":1,"highlight_end":28}],"label":"similarly named struct `CoreExtractionConfig` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":3133,"byte_end":3151,"line_start":156,"line_end":156,"column_start":15,"column_end":33,"is_primary":true,"text":[{"text":"    r#config: r#ExtractionConfig,","highlight_start":15,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a struct with a similar name exists","code":null,"level":"help","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":3133,"byte_end":3151,"line_start":156,"line_end":156,"column_start":15,"column_end":33,"is_primary":true,"text":[{"text":"    r#config: r#ExtractionConfig,","highlight_start":15,"highlight_end":33}],"label":null,"suggested_replacement":"CoreExtractionConfig","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":736,"byte_end":736,"line_start":27,"line_end":27,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub use error::{Error, Result};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::types::ExtractionConfig;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `ExtractionConfig` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:156:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m156\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     r#config: r#ExtractionConfig,\n    \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/types.rs:8:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ExtractionConfig {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m---------------------------\u001b[0m \u001b[1m\u001b[94msimilarly named struct `CoreExtractionConfig` defined here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: a struct with a similar name exists\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m156\u001b[0m \u001b[91m- \u001b[0m    r#config: \u001b[91mr#ExtractionConfig\u001b[0m,\n\u001b[1m\u001b[94m156\u001b[0m \u001b[92m+ \u001b[0m    r#config: \u001b[92mCoreExtractionConfig\u001b[0m,\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:27:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m27\u001b[0m \u001b[92m+ use crate::types::ExtractionConfig;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `DataSourceType` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":3172,"byte_end":3188,"line_start":157,"line_end":157,"column_start":20,"column_end":36,"is_primary":true,"text":[{"text":"    r#source_type: r#DataSourceType,","highlight_start":20,"highlight_end":36}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `DataSourceType` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:157:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m157\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     r#source_type: r#DataSourceType,\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `ExtractionReport` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/types.rs","byte_start":1618,"byte_end":1645,"line_start":63,"line_end":63,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"pub struct ExtractionResult {","highlight_start":1,"highlight_end":28}],"label":"similarly named struct `ExtractionResult` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":3219,"byte_end":3237,"line_start":158,"line_end":158,"column_start":30,"column_end":48,"is_primary":true,"text":[{"text":") -> ::std::result::Result::<r#ExtractionReport, r#ExtractionError>","highlight_start":30,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a struct with a similar name exists","code":null,"level":"help","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":3219,"byte_end":3237,"line_start":158,"line_end":158,"column_start":30,"column_end":48,"is_primary":true,"text":[{"text":") -> ::std::result::Result::<r#ExtractionReport, r#ExtractionError>","highlight_start":30,"highlight_end":48}],"label":null,"suggested_replacement":"ExtractionResult","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `ExtractionReport` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:158:30\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m158\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ::std::result::Result::<r#ExtractionReport, r#ExtractionError>\n    \u001b[1m\u001b[94m|\u001b[0m                              \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: a struct with a similar name exists: `ExtractionResult`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/types.rs:63:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m63\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ExtractionResult {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m---------------------------\u001b[0m \u001b[1m\u001b[94msimilarly named struct `ExtractionResult` defined here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `ExtractionError` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":3239,"byte_end":3256,"line_start":158,"line_end":158,"column_start":50,"column_end":67,"is_primary":true,"text":[{"text":") -> ::std::result::Result::<r#ExtractionReport, r#ExtractionError>","highlight_start":50,"highlight_end":67}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `ExtractionError` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:158:50\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m158\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ::std::result::Result::<r#ExtractionReport, r#ExtractionError>\n    \u001b[1m\u001b[94m|\u001b[0m                                                  \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `DatabaseStats` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":3410,"byte_end":3425,"line_start":167,"line_end":167,"column_start":30,"column_end":45,"is_primary":true,"text":[{"text":") -> ::std::result::Result::<r#DatabaseStats, r#ExtractionError>","highlight_start":30,"highlight_end":45}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `DatabaseStats` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:167:30\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m167\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ::std::result::Result::<r#DatabaseStats, r#ExtractionError>\n    \u001b[1m\u001b[94m|\u001b[0m                              \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `ExtractionError` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":3427,"byte_end":3444,"line_start":167,"line_end":167,"column_start":47,"column_end":64,"is_primary":true,"text":[{"text":") -> ::std::result::Result::<r#DatabaseStats, r#ExtractionError>","highlight_start":47,"highlight_end":64}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `ExtractionError` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:167:47\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m167\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> ::std::result::Result::<r#DatabaseStats, r#ExtractionError>\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `DataSourceInfo` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":3546,"byte_end":3562,"line_start":175,"line_end":175,"column_start":20,"column_end":36,"is_primary":true,"text":[{"text":") -> std::vec::Vec<r#DataSourceInfo>","highlight_start":20,"highlight_end":36}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `DataSourceInfo` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:175:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m175\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> std::vec::Vec<r#DataSourceInfo>\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `DataSourceType`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":847,"byte_end":861,"line_start":21,"line_end":21,"column_start":9,"column_end":23,"is_primary":true,"text":[{"text":"        DataSourceType::Messages,","highlight_start":9,"highlight_end":23}],"label":"use of undeclared type `DataSourceType`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `DataSourceType`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:21:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         DataSourceType::Messages,\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `DataSourceType`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `DataSourceType`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":881,"byte_end":895,"line_start":22,"line_end":22,"column_start":9,"column_end":23,"is_primary":true,"text":[{"text":"        DataSourceType::Chrome,","highlight_start":9,"highlight_end":23}],"label":"use of undeclared type `DataSourceType`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `DataSourceType`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:22:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         DataSourceType::Chrome,\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `DataSourceType`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `DataSourceType`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":913,"byte_end":927,"line_start":23,"line_end":23,"column_start":9,"column_end":23,"is_primary":true,"text":[{"text":"        DataSourceType::KnowledgeC,","highlight_start":9,"highlight_end":23}],"label":"use of undeclared type `DataSourceType`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `DataSourceType`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:23:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         DataSourceType::KnowledgeC,\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `DataSourceType`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `DataSourceType`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":949,"byte_end":963,"line_start":24,"line_end":24,"column_start":9,"column_end":23,"is_primary":true,"text":[{"text":"        DataSourceType::Podcasts,","highlight_start":9,"highlight_end":23}],"label":"use of undeclared type `DataSourceType`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `DataSourceType`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:24:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         DataSourceType::Podcasts,\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `DataSourceType`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":11945,"byte_end":11948,"line_start":319,"line_end":319,"column_start":63,"column_end":66,"is_primary":false,"text":[{"text":"        .query_row(\"SELECT COUNT(*) FROM messages\", [], |row| row.get(0))","highlight_start":63,"highlight_end":66}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/uniffi_api.rs","byte_start":11940,"byte_end":11943,"line_start":319,"line_end":319,"column_start":58,"column_end":61,"is_primary":true,"text":[{"text":"        .query_row(\"SELECT COUNT(*) FROM messages\", [], |row| row.get(0))","highlight_start":58,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/uniffi_api.rs","byte_start":11943,"byte_end":11943,"line_start":319,"line_end":319,"column_start":61,"column_end":61,"is_primary":true,"text":[{"text":"        .query_row(\"SELECT COUNT(*) FROM messages\", [], |row| row.get(0))","highlight_start":61,"highlight_end":61}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:319:58\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m319\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .query_row(\"SELECT COUNT(*) FROM messages\", [], |row| row.get(0))\n    \u001b[1m\u001b[94m|\u001b[0m                                                          \u001b[1m\u001b[91m^^^\u001b[0m  \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m319\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        .query_row(\"SELECT COUNT(*) FROM messages\", [], |row\u001b[92m: /* Type */\u001b[0m| row.get(0))\n    \u001b[1m\u001b[94m|\u001b[0m                                                             \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":12082,"byte_end":12085,"line_start":323,"line_end":323,"column_start":65,"column_end":68,"is_primary":false,"text":[{"text":"        .query_row(\"SELECT COUNT(*) FROM web_visits\", [], |row| row.get(0))","highlight_start":65,"highlight_end":68}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/uniffi_api.rs","byte_start":12077,"byte_end":12080,"line_start":323,"line_end":323,"column_start":60,"column_end":63,"is_primary":true,"text":[{"text":"        .query_row(\"SELECT COUNT(*) FROM web_visits\", [], |row| row.get(0))","highlight_start":60,"highlight_end":63}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/uniffi_api.rs","byte_start":12080,"byte_end":12080,"line_start":323,"line_end":323,"column_start":63,"column_end":63,"is_primary":true,"text":[{"text":"        .query_row(\"SELECT COUNT(*) FROM web_visits\", [], |row| row.get(0))","highlight_start":63,"highlight_end":63}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:323:60\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m323\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .query_row(\"SELECT COUNT(*) FROM web_visits\", [], |row| row.get(0))\n    \u001b[1m\u001b[94m|\u001b[0m                                                            \u001b[1m\u001b[91m^^^\u001b[0m  \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m323\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        .query_row(\"SELECT COUNT(*) FROM web_visits\", [], |row\u001b[92m: /* Type */\u001b[0m| row.get(0))\n    \u001b[1m\u001b[94m|\u001b[0m                                                               \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":12217,"byte_end":12220,"line_start":327,"line_end":327,"column_start":64,"column_end":67,"is_primary":false,"text":[{"text":"        .query_row(\"SELECT COUNT(*) FROM app_usage\", [], |row| row.get(0))","highlight_start":64,"highlight_end":67}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/uniffi_api.rs","byte_start":12212,"byte_end":12215,"line_start":327,"line_end":327,"column_start":59,"column_end":62,"is_primary":true,"text":[{"text":"        .query_row(\"SELECT COUNT(*) FROM app_usage\", [], |row| row.get(0))","highlight_start":59,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/uniffi_api.rs","byte_start":12215,"byte_end":12215,"line_start":327,"line_end":327,"column_start":62,"column_end":62,"is_primary":true,"text":[{"text":"        .query_row(\"SELECT COUNT(*) FROM app_usage\", [], |row| row.get(0))","highlight_start":62,"highlight_end":62}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:327:59\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m327\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .query_row(\"SELECT COUNT(*) FROM app_usage\", [], |row| row.get(0))\n    \u001b[1m\u001b[94m|\u001b[0m                                                           \u001b[1m\u001b[91m^^^\u001b[0m  \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m327\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        .query_row(\"SELECT COUNT(*) FROM app_usage\", [], |row\u001b[92m: /* Type */\u001b[0m| row.get(0))\n    \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":12380,"byte_end":12383,"line_start":332,"line_end":332,"column_start":13,"column_end":16,"is_primary":false,"text":[{"text":"            row.get(0)","highlight_start":13,"highlight_end":16}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/uniffi_api.rs","byte_start":12361,"byte_end":12364,"line_start":331,"line_end":331,"column_start":66,"column_end":69,"is_primary":true,"text":[{"text":"        .query_row(\"SELECT COUNT(*) FROM podcast_episodes\", [], |row| {","highlight_start":66,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/uniffi_api.rs","byte_start":12364,"byte_end":12364,"line_start":331,"line_end":331,"column_start":69,"column_end":69,"is_primary":true,"text":[{"text":"        .query_row(\"SELECT COUNT(*) FROM podcast_episodes\", [], |row| {","highlight_start":69,"highlight_end":69}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:331:66\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m331\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .query_row(\"SELECT COUNT(*) FROM podcast_episodes\", [], |row| {\n    \u001b[1m\u001b[94m|\u001b[0m                                                                  \u001b[1m\u001b[91m^^^\u001b[0m\n\u001b[1m\u001b[94m332\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             row.get(0)\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m331\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        .query_row(\"SELECT COUNT(*) FROM podcast_episodes\", [], |row\u001b[92m: /* Type */\u001b[0m| {\n    \u001b[1m\u001b[94m|\u001b[0m                                                                     \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":12960,"byte_end":12963,"line_start":348,"line_end":348,"column_start":23,"column_end":26,"is_primary":false,"text":[{"text":"                |row| row.get(0),","highlight_start":23,"highlight_end":26}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/uniffi_api.rs","byte_start":12955,"byte_end":12958,"line_start":348,"line_end":348,"column_start":18,"column_end":21,"is_primary":true,"text":[{"text":"                |row| row.get(0),","highlight_start":18,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/uniffi_api.rs","byte_start":12958,"byte_end":12958,"line_start":348,"line_end":348,"column_start":21,"column_end":21,"is_primary":true,"text":[{"text":"                |row| row.get(0),","highlight_start":21,"highlight_end":21}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:348:18\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m348\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 |row| row.get(0),\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[91m^^^\u001b[0m  \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m348\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                |row\u001b[92m: /* Type */\u001b[0m| row.get(0),\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/uniffi_api.rs","byte_start":13208,"byte_end":13211,"line_start":357,"line_end":357,"column_start":23,"column_end":26,"is_primary":false,"text":[{"text":"                |row| row.get(0),","highlight_start":23,"highlight_end":26}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/uniffi_api.rs","byte_start":13203,"byte_end":13206,"line_start":357,"line_end":357,"column_start":18,"column_end":21,"is_primary":true,"text":[{"text":"                |row| row.get(0),","highlight_start":18,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/uniffi_api.rs","byte_start":13206,"byte_end":13206,"line_start":357,"line_end":357,"column_start":21,"column_end":21,"is_primary":true,"text":[{"text":"                |row| row.get(0),","highlight_start":21,"highlight_end":21}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/uniffi_api.rs:357:18\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m357\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 |row| row.get(0),\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[91m^^^\u001b[0m  \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m357\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                |row\u001b[92m: /* Type */\u001b[0m| row.get(0),\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"associated type `Messages` not found for `Self`","code":{"code":"E0220","explanation":"The associated type used was not defined in the trait.\n\nErroneous code example:\n\n```compile_fail,E0220\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<F=i32>; // error: associated type `F` not found for `T1`\n\n// or:\n\ntrait T2 {\n    type Bar;\n\n    // error: Baz is used but not declared\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n\nMake sure that you have defined the associated type in the trait body.\nAlso, verify that you used the right trait or you didn't misspell the\nassociated type name. Example:\n\n```\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<Bar=i32>; // ok!\n\n// or:\n\ntrait T2 {\n    type Bar;\n    type Baz; // we declare `Baz` in our trait.\n\n    // and now we can use it here:\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":867,"byte_end":877,"line_start":47,"line_end":47,"column_start":5,"column_end":15,"is_primary":true,"text":[{"text":"    r#Messages {","highlight_start":5,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`Self` has the following associated type","code":null,"level":"help","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":867,"byte_end":877,"line_start":47,"line_end":47,"column_start":5,"column_end":15,"is_primary":true,"text":[{"text":"    r#Messages {","highlight_start":5,"highlight_end":15}],"label":null,"suggested_replacement":"FfiType","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0220]\u001b[0m\u001b[1m: associated type `Messages` not found for `Self`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:47:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     r#Messages {\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: `Self` has the following associated type: `FfiType`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"associated type `Chrome` not found for `Self`","code":{"code":"E0220","explanation":"The associated type used was not defined in the trait.\n\nErroneous code example:\n\n```compile_fail,E0220\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<F=i32>; // error: associated type `F` not found for `T1`\n\n// or:\n\ntrait T2 {\n    type Bar;\n\n    // error: Baz is used but not declared\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n\nMake sure that you have defined the associated type in the trait body.\nAlso, verify that you used the right trait or you didn't misspell the\nassociated type name. Example:\n\n```\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<Bar=i32>; // ok!\n\n// or:\n\ntrait T2 {\n    type Bar;\n    type Baz; // we declare `Baz` in our trait.\n\n    // and now we can use it here:\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":891,"byte_end":899,"line_start":49,"line_end":49,"column_start":5,"column_end":13,"is_primary":true,"text":[{"text":"    r#Chrome {","highlight_start":5,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`Self` has the following associated type","code":null,"level":"help","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":891,"byte_end":899,"line_start":49,"line_end":49,"column_start":5,"column_end":13,"is_primary":true,"text":[{"text":"    r#Chrome {","highlight_start":5,"highlight_end":13}],"label":null,"suggested_replacement":"FfiType","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0220]\u001b[0m\u001b[1m: associated type `Chrome` not found for `Self`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:49:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     r#Chrome {\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: `Self` has the following associated type: `FfiType`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"associated type `KnowledgeC` not found for `Self`","code":{"code":"E0220","explanation":"The associated type used was not defined in the trait.\n\nErroneous code example:\n\n```compile_fail,E0220\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<F=i32>; // error: associated type `F` not found for `T1`\n\n// or:\n\ntrait T2 {\n    type Bar;\n\n    // error: Baz is used but not declared\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n\nMake sure that you have defined the associated type in the trait body.\nAlso, verify that you used the right trait or you didn't misspell the\nassociated type name. Example:\n\n```\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<Bar=i32>; // ok!\n\n// or:\n\ntrait T2 {\n    type Bar;\n    type Baz; // we declare `Baz` in our trait.\n\n    // and now we can use it here:\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":913,"byte_end":925,"line_start":51,"line_end":51,"column_start":5,"column_end":17,"is_primary":true,"text":[{"text":"    r#KnowledgeC {","highlight_start":5,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`Self` has the following associated type","code":null,"level":"help","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":913,"byte_end":925,"line_start":51,"line_end":51,"column_start":5,"column_end":17,"is_primary":true,"text":[{"text":"    r#KnowledgeC {","highlight_start":5,"highlight_end":17}],"label":null,"suggested_replacement":"FfiType","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0220]\u001b[0m\u001b[1m: associated type `KnowledgeC` not found for `Self`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:51:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     r#KnowledgeC {\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: `Self` has the following associated type: `FfiType`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"associated type `Podcasts` not found for `Self`","code":{"code":"E0220","explanation":"The associated type used was not defined in the trait.\n\nErroneous code example:\n\n```compile_fail,E0220\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<F=i32>; // error: associated type `F` not found for `T1`\n\n// or:\n\ntrait T2 {\n    type Bar;\n\n    // error: Baz is used but not declared\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n\nMake sure that you have defined the associated type in the trait body.\nAlso, verify that you used the right trait or you didn't misspell the\nassociated type name. Example:\n\n```\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<Bar=i32>; // ok!\n\n// or:\n\ntrait T2 {\n    type Bar;\n    type Baz; // we declare `Baz` in our trait.\n\n    // and now we can use it here:\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":939,"byte_end":949,"line_start":53,"line_end":53,"column_start":5,"column_end":15,"is_primary":true,"text":[{"text":"    r#Podcasts {","highlight_start":5,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`Self` has the following associated type","code":null,"level":"help","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":939,"byte_end":949,"line_start":53,"line_end":53,"column_start":5,"column_end":15,"is_primary":true,"text":[{"text":"    r#Podcasts {","highlight_start":5,"highlight_end":15}],"label":null,"suggested_replacement":"FfiType","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0220]\u001b[0m\u001b[1m: associated type `Podcasts` not found for `Self`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:53:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     r#Podcasts {\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: `Self` has the following associated type: `FfiType`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"associated type `Messages` not found for `Self`","code":{"code":"E0220","explanation":"The associated type used was not defined in the trait.\n\nErroneous code example:\n\n```compile_fail,E0220\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<F=i32>; // error: associated type `F` not found for `T1`\n\n// or:\n\ntrait T2 {\n    type Bar;\n\n    // error: Baz is used but not declared\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n\nMake sure that you have defined the associated type in the trait body.\nAlso, verify that you used the right trait or you didn't misspell the\nassociated type name. Example:\n\n```\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<Bar=i32>; // ok!\n\n// or:\n\ntrait T2 {\n    type Bar;\n    type Baz; // we declare `Baz` in our trait.\n\n    // and now we can use it here:\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":867,"byte_end":877,"line_start":47,"line_end":47,"column_start":5,"column_end":15,"is_primary":true,"text":[{"text":"    r#Messages {","highlight_start":5,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`Self` has the following associated type","code":null,"level":"help","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":867,"byte_end":877,"line_start":47,"line_end":47,"column_start":5,"column_end":15,"is_primary":true,"text":[{"text":"    r#Messages {","highlight_start":5,"highlight_end":15}],"label":null,"suggested_replacement":"FfiType","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0220]\u001b[0m\u001b[1m: associated type `Messages` not found for `Self`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:47:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     r#Messages {\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: `Self` has the following associated type: `FfiType`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"associated type `Chrome` not found for `Self`","code":{"code":"E0220","explanation":"The associated type used was not defined in the trait.\n\nErroneous code example:\n\n```compile_fail,E0220\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<F=i32>; // error: associated type `F` not found for `T1`\n\n// or:\n\ntrait T2 {\n    type Bar;\n\n    // error: Baz is used but not declared\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n\nMake sure that you have defined the associated type in the trait body.\nAlso, verify that you used the right trait or you didn't misspell the\nassociated type name. Example:\n\n```\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<Bar=i32>; // ok!\n\n// or:\n\ntrait T2 {\n    type Bar;\n    type Baz; // we declare `Baz` in our trait.\n\n    // and now we can use it here:\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":891,"byte_end":899,"line_start":49,"line_end":49,"column_start":5,"column_end":13,"is_primary":true,"text":[{"text":"    r#Chrome {","highlight_start":5,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`Self` has the following associated type","code":null,"level":"help","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":891,"byte_end":899,"line_start":49,"line_end":49,"column_start":5,"column_end":13,"is_primary":true,"text":[{"text":"    r#Chrome {","highlight_start":5,"highlight_end":13}],"label":null,"suggested_replacement":"FfiType","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0220]\u001b[0m\u001b[1m: associated type `Chrome` not found for `Self`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:49:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     r#Chrome {\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: `Self` has the following associated type: `FfiType`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"associated type `KnowledgeC` not found for `Self`","code":{"code":"E0220","explanation":"The associated type used was not defined in the trait.\n\nErroneous code example:\n\n```compile_fail,E0220\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<F=i32>; // error: associated type `F` not found for `T1`\n\n// or:\n\ntrait T2 {\n    type Bar;\n\n    // error: Baz is used but not declared\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n\nMake sure that you have defined the associated type in the trait body.\nAlso, verify that you used the right trait or you didn't misspell the\nassociated type name. Example:\n\n```\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<Bar=i32>; // ok!\n\n// or:\n\ntrait T2 {\n    type Bar;\n    type Baz; // we declare `Baz` in our trait.\n\n    // and now we can use it here:\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":913,"byte_end":925,"line_start":51,"line_end":51,"column_start":5,"column_end":17,"is_primary":true,"text":[{"text":"    r#KnowledgeC {","highlight_start":5,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`Self` has the following associated type","code":null,"level":"help","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":913,"byte_end":925,"line_start":51,"line_end":51,"column_start":5,"column_end":17,"is_primary":true,"text":[{"text":"    r#KnowledgeC {","highlight_start":5,"highlight_end":17}],"label":null,"suggested_replacement":"FfiType","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0220]\u001b[0m\u001b[1m: associated type `KnowledgeC` not found for `Self`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:51:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     r#KnowledgeC {\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: `Self` has the following associated type: `FfiType`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"associated type `Podcasts` not found for `Self`","code":{"code":"E0220","explanation":"The associated type used was not defined in the trait.\n\nErroneous code example:\n\n```compile_fail,E0220\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<F=i32>; // error: associated type `F` not found for `T1`\n\n// or:\n\ntrait T2 {\n    type Bar;\n\n    // error: Baz is used but not declared\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n\nMake sure that you have defined the associated type in the trait body.\nAlso, verify that you used the right trait or you didn't misspell the\nassociated type name. Example:\n\n```\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<Bar=i32>; // ok!\n\n// or:\n\ntrait T2 {\n    type Bar;\n    type Baz; // we declare `Baz` in our trait.\n\n    // and now we can use it here:\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":939,"byte_end":949,"line_start":53,"line_end":53,"column_start":5,"column_end":15,"is_primary":true,"text":[{"text":"    r#Podcasts {","highlight_start":5,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`Self` has the following associated type","code":null,"level":"help","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":939,"byte_end":949,"line_start":53,"line_end":53,"column_start":5,"column_end":15,"is_primary":true,"text":[{"text":"    r#Podcasts {","highlight_start":5,"highlight_end":15}],"label":null,"suggested_replacement":"FfiType","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0220]\u001b[0m\u001b[1m: associated type `Podcasts` not found for `Self`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:53:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     r#Podcasts {\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: `Self` has the following associated type: `FfiType`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"associated type `DatabaseError` not found for `Self`","code":{"code":"E0220","explanation":"The associated type used was not defined in the trait.\n\nErroneous code example:\n\n```compile_fail,E0220\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<F=i32>; // error: associated type `F` not found for `T1`\n\n// or:\n\ntrait T2 {\n    type Bar;\n\n    // error: Baz is used but not declared\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n\nMake sure that you have defined the associated type in the trait body.\nAlso, verify that you used the right trait or you didn't misspell the\nassociated type name. Example:\n\n```\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<Bar=i32>; // ok!\n\n// or:\n\ntrait T2 {\n    type Bar;\n    type Baz; // we declare `Baz` in our trait.\n\n    // and now we can use it here:\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":1108,"byte_end":1123,"line_start":66,"line_end":66,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"    r#DatabaseError {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`Self` has the following associated type","code":null,"level":"help","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":1108,"byte_end":1123,"line_start":66,"line_end":66,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"    r#DatabaseError {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":"FfiType","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0220]\u001b[0m\u001b[1m: associated type `DatabaseError` not found for `Self`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:66:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m66\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     r#DatabaseError {\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: `Self` has the following associated type: `FfiType`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"associated type `SourceNotFound` not found for `Self`","code":{"code":"E0220","explanation":"The associated type used was not defined in the trait.\n\nErroneous code example:\n\n```compile_fail,E0220\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<F=i32>; // error: associated type `F` not found for `T1`\n\n// or:\n\ntrait T2 {\n    type Bar;\n\n    // error: Baz is used but not declared\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n\nMake sure that you have defined the associated type in the trait body.\nAlso, verify that you used the right trait or you didn't misspell the\nassociated type name. Example:\n\n```\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<Bar=i32>; // ok!\n\n// or:\n\ntrait T2 {\n    type Bar;\n    type Baz; // we declare `Baz` in our trait.\n\n    // and now we can use it here:\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":1137,"byte_end":1153,"line_start":68,"line_end":68,"column_start":5,"column_end":21,"is_primary":true,"text":[{"text":"    r#SourceNotFound {","highlight_start":5,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`Self` has the following associated type","code":null,"level":"help","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":1137,"byte_end":1153,"line_start":68,"line_end":68,"column_start":5,"column_end":21,"is_primary":true,"text":[{"text":"    r#SourceNotFound {","highlight_start":5,"highlight_end":21}],"label":null,"suggested_replacement":"FfiType","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0220]\u001b[0m\u001b[1m: associated type `SourceNotFound` not found for `Self`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:68:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m68\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     r#SourceNotFound {\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: `Self` has the following associated type: `FfiType`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"associated type `PermissionDenied` not found for `Self`","code":{"code":"E0220","explanation":"The associated type used was not defined in the trait.\n\nErroneous code example:\n\n```compile_fail,E0220\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<F=i32>; // error: associated type `F` not found for `T1`\n\n// or:\n\ntrait T2 {\n    type Bar;\n\n    // error: Baz is used but not declared\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n\nMake sure that you have defined the associated type in the trait body.\nAlso, verify that you used the right trait or you didn't misspell the\nassociated type name. Example:\n\n```\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<Bar=i32>; // ok!\n\n// or:\n\ntrait T2 {\n    type Bar;\n    type Baz; // we declare `Baz` in our trait.\n\n    // and now we can use it here:\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":1167,"byte_end":1185,"line_start":70,"line_end":70,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"    r#PermissionDenied {","highlight_start":5,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`Self` has the following associated type","code":null,"level":"help","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":1167,"byte_end":1185,"line_start":70,"line_end":70,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"    r#PermissionDenied {","highlight_start":5,"highlight_end":23}],"label":null,"suggested_replacement":"FfiType","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0220]\u001b[0m\u001b[1m: associated type `PermissionDenied` not found for `Self`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:70:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m70\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     r#PermissionDenied {\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: `Self` has the following associated type: `FfiType`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"associated type `InvalidPath` not found for `Self`","code":{"code":"E0220","explanation":"The associated type used was not defined in the trait.\n\nErroneous code example:\n\n```compile_fail,E0220\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<F=i32>; // error: associated type `F` not found for `T1`\n\n// or:\n\ntrait T2 {\n    type Bar;\n\n    // error: Baz is used but not declared\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n\nMake sure that you have defined the associated type in the trait body.\nAlso, verify that you used the right trait or you didn't misspell the\nassociated type name. Example:\n\n```\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<Bar=i32>; // ok!\n\n// or:\n\ntrait T2 {\n    type Bar;\n    type Baz; // we declare `Baz` in our trait.\n\n    // and now we can use it here:\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":1199,"byte_end":1212,"line_start":72,"line_end":72,"column_start":5,"column_end":18,"is_primary":true,"text":[{"text":"    r#InvalidPath {","highlight_start":5,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`Self` has the following associated type","code":null,"level":"help","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":1199,"byte_end":1212,"line_start":72,"line_end":72,"column_start":5,"column_end":18,"is_primary":true,"text":[{"text":"    r#InvalidPath {","highlight_start":5,"highlight_end":18}],"label":null,"suggested_replacement":"FfiType","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0220]\u001b[0m\u001b[1m: associated type `InvalidPath` not found for `Self`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:72:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     r#InvalidPath {\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: `Self` has the following associated type: `FfiType`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"associated type `ExtractionFailed` not found for `Self`","code":{"code":"E0220","explanation":"The associated type used was not defined in the trait.\n\nErroneous code example:\n\n```compile_fail,E0220\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<F=i32>; // error: associated type `F` not found for `T1`\n\n// or:\n\ntrait T2 {\n    type Bar;\n\n    // error: Baz is used but not declared\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n\nMake sure that you have defined the associated type in the trait body.\nAlso, verify that you used the right trait or you didn't misspell the\nassociated type name. Example:\n\n```\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<Bar=i32>; // ok!\n\n// or:\n\ntrait T2 {\n    type Bar;\n    type Baz; // we declare `Baz` in our trait.\n\n    // and now we can use it here:\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":1226,"byte_end":1244,"line_start":74,"line_end":74,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"    r#ExtractionFailed {","highlight_start":5,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`Self` has the following associated type","code":null,"level":"help","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":1226,"byte_end":1244,"line_start":74,"line_end":74,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"    r#ExtractionFailed {","highlight_start":5,"highlight_end":23}],"label":null,"suggested_replacement":"FfiType","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0220]\u001b[0m\u001b[1m: associated type `ExtractionFailed` not found for `Self`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:74:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     r#ExtractionFailed {\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: `Self` has the following associated type: `FfiType`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"associated type `Other` not found for `Self`","code":{"code":"E0220","explanation":"The associated type used was not defined in the trait.\n\nErroneous code example:\n\n```compile_fail,E0220\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<F=i32>; // error: associated type `F` not found for `T1`\n\n// or:\n\ntrait T2 {\n    type Bar;\n\n    // error: Baz is used but not declared\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n\nMake sure that you have defined the associated type in the trait body.\nAlso, verify that you used the right trait or you didn't misspell the\nassociated type name. Example:\n\n```\ntrait T1 {\n    type Bar;\n}\n\ntype Foo = T1<Bar=i32>; // ok!\n\n// or:\n\ntrait T2 {\n    type Bar;\n    type Baz; // we declare `Baz` in our trait.\n\n    // and now we can use it here:\n    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":1258,"byte_end":1265,"line_start":76,"line_end":76,"column_start":5,"column_end":12,"is_primary":true,"text":[{"text":"    r#Other {","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`Self` has the following associated type","code":null,"level":"help","spans":[{"file_name":"/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs","byte_start":1258,"byte_end":1265,"line_start":76,"line_end":76,"column_start":5,"column_end":12,"is_primary":true,"text":[{"text":"    r#Other {","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":"FfiType","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0220]\u001b[0m\u001b[1m: associated type `Other` not found for `Self`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/tevonstrand-brown/Desktop/qualified-extraction/quantified-core/target/debug/build/quantified-core-b85a6a50bb554ccd/out/quantified.uniffi.rs:76:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m76\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     r#Other {\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: `Self` has the following associated type: `FfiType`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 94 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 94 previous errors\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0220, E0282, E0412, E0422, E0433.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0220, E0282, E0412, E0422, E0433.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0220`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0220`.\u001b[0m\n"}
